import typing
from enum import Enum
from math import log10

import numpy as np


class DataType(Enum):
    """
    The possible types of data that can be generated by this tool.

    CIRCLE: circles around a fixed point, each getting larger radii from each other.

    SEPARATED_BLOBS: Separated blobs of data, each randomly positioned.

    GIANT_BLOB: A giant blob at a fixed point. Only a single one will be generated.
    """
    CIRCLE = 1
    SEPARATED_BLOBS = 2
    GIANT_BLOB = 3


def _generate_blob(total_amt_of_points: int, origin_x: float = 0, origin_y: float = 0, radius: float = 1) -> np.ndarray:
    """
    Generate a blob of data in a semi-circular format.
    :param total_amt_of_points: The total number of data points to generate
    :param origin_x: The x coordinate of the center of the blob
    :param origin_y: The y coordinate of the center of the blob
    :param radius: The max distance from the center any point can be.
    :return: An ndarray shaped as [x values, y values]. Size is [2, total_num_of_points]
    """
    angles = np.random.random(size=(total_amt_of_points,)) * 2 * np.pi
    distance_from_origin = np.random.random(size=(total_amt_of_points,)) * radius
    return np.asarray(
        [np.cos(angles) * distance_from_origin + origin_x, np.sin(angles) * distance_from_origin + origin_y])


def _generate_circles(total_amt_of_data: int, num_of_classifications: int):
    """
    Generates circle outlines around each other. The number of outlines is determined by the number of classifications.
    :param total_amt_of_data: the total number of data points to generate
    :param num_of_classifications: the number of circles to generate.
    :return: an ndarray of the points in the format of [x values, y values]. Size is [2, total_amt_of_data]
    """
    raise NotImplementedError


def _generate_separated_blobs(total_amt_of_data: int, num_of_classifications: int, max_radius: float = 0,
                              origin_range_x: typing.Tuple[float, float] = (-1, 1),
                              origin_range_y: typing.Tuple[float, float] = (-1, 1), perfect: bool = False):
    """
    Generates blobs that are to be separated from each other. Each blob has approximately the same number of data points
    within it. If ``total_amt_of_data`` is not perfectly divisible by  ``num_of_classifications``, then the last blob
    generated will have less data points within it. This doesn't have if the ``perfect`` flag is set to false, which is
    default.

    :param total_amt_of_data: The total number of data points to be made.
    :param num_of_classifications: The number of blobs to make.
    :param max_radius: the max radius of the blobs. If radius is 0 (as per default), then max_radius is set to
                        ``log10(total_amt_of_data)``
    :param origin_range_x: The range of the x values for the origins in the format of (min, max)
    :param origin_range_y: The range of the y values for the origins in the format of (min, max)
    :param perfect: a flag that determines whether the actual number of data points is to be exactly equal to
                ``total_amt_of_data``. If set to False (the default), the last blob will have slightly less data
                points in it than the others.
    :return: an ndarray of all of the data points in the format of [x values, y values].
            Size is [2, ``total_amt_of_data``]
    """

    if perfect:
        total_data = total_amt_of_data
        blob_sizes = []
        for i in range(num_of_classifications):
            if num_of_classifications > total_data:
                blob_sizes.append(total_data)
            else:
                blob_sizes.append(num_of_classifications)
            total_data -= num_of_classifications
    else:
        blob_sizes = [total_amt_of_data // num_of_classifications] * num_of_classifications
    if max_radius is 0:
        max_radius = log10(total_amt_of_data)

    # Choose the origins so that none of them should be the same.
    num_of_origin_samples = (origin_range_x[1] - origin_range_x[0]) // max_radius
    if num_of_origin_samples < num_of_classifications:
        num_of_origin_samples = num_of_classifications
    origin_x_choices = np.linspace(origin_range_x[0], origin_range_x[1], num_of_origin_samples)

    num_of_origin_samples = (origin_range_y[1] - origin_range_y[0]) // max_radius
    if num_of_origin_samples < num_of_classifications:
        num_of_origin_samples = num_of_classifications
    origin_y_choices = np.linspace(origin_range_y[0], origin_range_y[1], num_of_origin_samples)

    origins = np.asarray([np.random.choice(origin_x_choices, size=num_of_classifications, replace=False),
                          np.random.choice(origin_y_choices, size=num_of_classifications, replace=False)])

    # actually generate each blob.
    blobs = np.asarray([_generate_blob(blob_sizes[i], radius=np.random.random() * max_radius, origin_x=origins[0][i],
                                       origin_y=origins[1][i]) for i in range(num_of_classifications)])
    return blobs.reshape((2, -1))


def _generate_giant_blob(total_amt_of_data: int) -> np.ndarray:
    """
    Generates a giant blob in the center of the data field. Radius is log_10 of the total amount of data.
    :param total_amt_of_data: the total number of data points to generate
    :return: an ndarray of data points with the format of [x values, y values]. Size is [2, total_amt_of_data]
    """
    radius: float = log10(total_amt_of_data)
    return _generate_blob(total_amt_of_points=total_amt_of_data, radius=radius)


def generate_data(total_amt_of_data: int, num_of_classifications: int, data_type: DataType,
                  arguments: typing.Dict = None) -> np.ndarray:
    """
    Generates a list of random data of 2 dimensions that is customizable by the parameters provided.

    :param total_amt_of_data: The total amount of data points to generate.
    :param num_of_classifications: The number of classifications the data can have.
    :param data_type: Determines how the data is to be generated, based off of its visual representation.
    :param arguments: The arguments to pass to each individual function based on the data type selected.
    :return: list of all of the data.
    """
    if data_type is DataType.CIRCLE:
        return _generate_circles(total_amt_of_data, num_of_classifications)
    elif data_type is DataType.SEPARATED_BLOBS:
        if arguments is None:
            return _generate_separated_blobs(total_amt_of_data, num_of_classifications)
        else:
            return _generate_separated_blobs(total_amt_of_data=total_amt_of_data,
                                             num_of_classifications=num_of_classifications,
                                             max_radius=arguments["max_radius"],
                                             origin_range_x=arguments["origin_range_x"],
                                             origin_range_y=arguments["origin_range_y"],
                                             perfect=arguments["perfect"])
    elif data_type is DataType.GIANT_BLOB:
        return _generate_giant_blob(total_amt_of_data)
    else:
        raise ValueError(
            f"Got unexpected DataType value for parameter 'data_type' in function generate_data: {data_type}")
